## Answer questions
# get default answers based on questions
get_defaults <- function(question_ids = names(get_questions())) {
  map(question_ids, get_default) %>% set_names(question_ids)
}

get_default <- function(question_id) {
  default <- questions[[question_id]][["default"]]

  default
}

# function which generates the documentation for the answers function based on all the questions
answer_questions_docs <- function() {
  parameters <- paste0(
    "@param ",
    names(questions),
    " ",
    map(questions, "label"),
    " Defaults to ",
    get_defaults(names(questions)) %>% as.character()
  )
}

#' Provide answers to various questions
#'
#' @include questions.R
#' @param dataset The dataset from which the answers will be computed
#' @eval answer_questions_docs()
#'
#' @export
answer_questions <- function(dataset = NULL, ...) {
  # get either the defaults or the arguments given by the user
  answers <- as.list(environment())
  answers <- answers[names(answers) != "dataset"]

  # get the question ids that were given by the user
  given_question_ids <- names(match.call())

  # get computed answers from dataset
  computed_question_ids <- character()
  if (!is.null(dataset)) {
    for (question_id in setdiff(names(questions), given_question_ids)) {
      if (is.function(questions[[question_id]]$default_dataset)) {
        answers[[question_id]][["default"]] <- list(questions[[question_id]]$default_dataset(dataset, answers[[question_id]])) # use list here to avoid xxx <- NULL removing the element
        computed_question_ids <- c(computed_question_ids, question_id)
      }
    }
  }

  tibble(
    question_id = names(answers),
    answer = answers,
    source = case_when(
      question_id %in% given_question_ids ~ "adapted",
      question_id %in% computed_question_ids ~ "computed",
      TRUE ~ "default"
    )
  )
}
formals(answer_questions) <- c(list(dataset = NULL), get_defaults(names(questions)))



#' Produces the code necessary to reproduce a particular set of guidelines
#'
#' @param answers An answers tibble as generated by [answer_questions()]
#'
#' @export
get_answers_code <- function(answers = answer_questions()) {
  params <- c()

  adapted_answers <- answers %>% filter(source %in% c("computed", "adapted"))
  params <-
    map2_chr(adapted_answers$question_id, adapted_answers$answer, function(question_id, answer) {
      glue::glue("{question_id} = {glue::glue_collapse(deparse(answer, width.cutoff = 80L))}")
    })

  if (length(params) == 0) {
    code <- "answers <- dynguidelines::answer_questions()"
  } else {
    code <- glue::glue(
      "answers <- dynguidelines::answer_questions(",
      glue::glue_collapse(paste0("  ", params), ", \n"),
      ")",
      .sep = "\n",
      .trim = FALSE
    )
  }

  code <- paste(
    code,
    "guidelines <- dynguidelines::guidelines(answers = answers)",
    sep = "\n"
  )

  code
}